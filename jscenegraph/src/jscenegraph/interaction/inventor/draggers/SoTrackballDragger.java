/*
 *
 *  Copyright (C) 2000 Silicon Graphics, Inc.  All Rights Reserved. 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  Further, this software is distributed without any warranty that it is
 *  free of the rightful claim of any third person regarding infringement
 *  or the like.  Any license provided herein, whether implied or
 *  otherwise, applies only to this software file.  Patent licenses, if
 *  any, provided herein do not apply to combinations of this program with
 *  other software, or any other product whatsoever.
 * 
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
 *  Mountain View, CA  94043, or:
 * 
 *  http://www.sgi.com 
 * 
 *  For further information regarding this notice, see: 
 * 
 *  http://oss.sgi.com/projects/GenInfo/NoticeExplan/
 *
 */


/*
 * Copyright (C) 1990,91   Silicon Graphics, Inc.
 *
 _______________________________________________________________________
 ______________  S I L I C O N   G R A P H I C S   I N C .  ____________
 |
 |   $Revision: 1.1.1.1 $
 |
 |   Description:
 |      This file defines the trackball dragger class.
 |
 | NOTE TO DEVELOPERS:
 |     For info about the structure of SoTrackballDragger:
 |     [1] compile: /usr/share/src/Inventor/samples/ivNodeKitStructure
 |     [2] type:    ivNodeKitStructure SoTrackballDragger.
 |     [3] The program prints a diagram of the scene graph and a table with 
 |         information about each part.
 |
 |  The following parts in this dragger are created at construction time.
 |  'ResourceName' corresponds to the name of the default geometry for the
 |  part. The dragger's constructor gets the scene graph for 'ResourceName'
 |  by querying the global dictionary ( SoDB.getByName("ResourceName"); ).  
 |
 |  Resource Name:                           Part Name:
 |
 |  trackballRotator                       - rotator     
 |  trackballRotatorActive                 - rotatorActive     
 |  trackballXRotator                      - XRotator    
 |  trackballXRotatorActive                - XRotatorActive    
 |  trackballYRotator,                     - YRotator   
 |  trackballYRotatorActive,               - YRotatorActive   
 |  trackballZRotator                      - ZRotator  
 |  trackballZRotatorActive                - ZRotatorActive  
 |  trackballUserAxis                      - userAxis    
 |  trackballUserAxisActive                - userAxisActive    
 |  trackballUserRotator                   - userRotator 
 |  trackballUserRotatorActive             - userRotatorActive 
 |
 |   Author(s): Paul Isaacs, David Mott
 |
 ______________  S I L I C O N   G R A P H I C S   I N C .  ____________
 _______________________________________________________________________
 */

package jscenegraph.interaction.inventor.draggers;

import jscenegraph.database.inventor.SbCylinder;
import jscenegraph.database.inventor.SbLine;
import jscenegraph.database.inventor.SbMatrix;
import jscenegraph.database.inventor.SbName;
import jscenegraph.database.inventor.SbRotation;
import jscenegraph.database.inventor.SbSphere;
import jscenegraph.database.inventor.SbTime;
import jscenegraph.database.inventor.SbVec3f;
import jscenegraph.database.inventor.SoPath;
import jscenegraph.database.inventor.SoType;
import jscenegraph.database.inventor.actions.SoHandleEventAction;
import jscenegraph.database.inventor.errors.SoDebugError;
import jscenegraph.database.inventor.events.SoEvent;
import jscenegraph.database.inventor.events.SoKeyboardEvent;
import jscenegraph.database.inventor.fields.SoFieldData;
import jscenegraph.database.inventor.fields.SoSFNode;
import jscenegraph.database.inventor.fields.SoSFRotation;
import jscenegraph.database.inventor.fields.SoSFVec3f;
import jscenegraph.database.inventor.nodes.SoRotation;
import jscenegraph.database.inventor.nodes.SoSeparator;
import jscenegraph.database.inventor.nodes.SoSubNode;
import jscenegraph.database.inventor.nodes.SoSwitch;
import jscenegraph.database.inventor.projectors.SbCylinderPlaneProjector;
import jscenegraph.database.inventor.projectors.SbCylinderProjector;
import jscenegraph.database.inventor.projectors.SbLineProjector;
import jscenegraph.database.inventor.projectors.SbProjector;
import jscenegraph.database.inventor.projectors.SbSphereProjector;
import jscenegraph.database.inventor.projectors.SbSphereSectionProjector;
import jscenegraph.database.inventor.sensors.SoFieldSensor;
import jscenegraph.database.inventor.sensors.SoSensor;
import jscenegraph.database.inventor.sensors.SoTimerSensor;
import jscenegraph.interaction.inventor.nodekits.SoInteractionKit;
import jscenegraph.interaction.inventor.nodes.SoAntiSquish;
import jscenegraph.interaction.inventor.nodes.SoSurroundScale;
import jscenegraph.nodekits.inventor.nodekits.SoBaseKit;
import jscenegraph.nodekits.inventor.nodekits.SoNodekitCatalog;
import jscenegraph.nodekits.inventor.nodekits.SoSubKit;

/**
 * @author Yves Boyadjian
 *
 */


////////////////////////////////////////////////////////////////////////////////
//! Striped ball you can rotate or scale uniformly by dragging with the mouse.
/*!
\class SoTrackballDragger
\ingroup Draggers
SoTrackballDragger 
is a ball wrapped in three circular stripes.  The stripes are oriented
like wheels that spin around the x, y, and z axes.  Drag the stripes
to rotate the trackball around those axes.  You do not have to hit the lines;
pick anywhere within the stripe's outline.  To rotate the trackball
freely in 3 dimensions, click the area 
between the stripes and then drag.  An invisible but
pickable sphere initiates this dragging.  If the mouse is still moving when
you release it,  the trackball will continue to  spin.


Press the <tt>&lt;Control&gt;</tt> key to scale the trackball uniformly instead of 
rotating.


Press the <tt>&lt;Shift&gt;</tt> key and the <em>user axis</em> appears; this is a
draggable axis with an extra stripe around it.   
Moving the mouse along the surface of the sphere drags the
'pole' of the axis.  
Release the <tt>&lt;Shift&gt;</tt> key and the user axis remains; drag the
new stripe for constrained rotation around the user axis.
To make the user axis disappear, press <tt>&lt;Shift&gt;</tt> and drag the pole to
where two of other stripes intersect. This aligns the user axis with 
a primary axis, at which point the user axis disappears.


As you drag the trackball, it updates its
\b rotation  field, or its \b scaleFactor  field if 
the <tt>&lt;Control&gt;</tt> key is down. As with all draggers, if you change the 
fields the dragger moves in response.


\p Remember: This is <em>not</em> an SoTransform!. 
If you want to move other objects with this dragger, you can either: 


[a] Use an SoTrackballManip, which is subclassed from SoTransform. 
The manipulator creates one of
these draggers and uses it as the interface to edit the manipulator's fields.
(see the SoTrackballManip reference page).  


[b] Use field-to-field connections to connect the fields of this dragger to
those of any SoTransformation node.


You can change the parts in any instance of this dragger using
setPart().
The default part geometries are defined as resources for this 
SoTrackballDragger class.  They are detailed in the 
Dragger Resources section of the online reference page for this class.
You can make your program use different default resources for the parts
by copying the file
\b /usr/share/data/draggerDefaults/trackballDragger.iv 
into your own directory, editing the file, and then
setting the environment variable \b SO_DRAGGER_DIR  to be a path to that directory.

\par File Format/Default
\par
\code
TrackballDragger {
  renderCaching AUTO
  boundingBoxCaching AUTO
  renderCulling AUTO
  pickCulling AUTO
  isActive false
  rotation 0 0 1 0
  scaleFactor 1 1 1
}
\endcode
\par
NOTE
  Unlike most multi-function draggers,  SoTrackballDragger is
not a compound dragger made up of other draggers that
perform its smaller tasks.  This is 
not because it was inappropriate, but because
the trackball was written before implementation of the methods that
take care of synchronizing multiple child draggers. The younger 
SoCenterballDragger is similar in form to the trackball, but 
the centerball <em>is</em> a compound dragger. 
\par See Also
\par
SoInteractionKit, SoDragger, SoCenterballDragger, SoDirectionalLightDragger, SoDragPointDragger, SoHandleBoxDragger, SoJackDragger, SoPointLightDragger, SoRotateCylindricalDragger, SoRotateDiscDragger, SoRotateSphericalDragger, SoScale1Dragger, SoScale2Dragger, SoScale2UniformDragger, SoScaleUniformDragger, SoSpotLightDragger, SoTabBoxDragger, SoTabPlaneDragger, SoTransformBoxDragger, SoTransformerDragger, SoTranslate1Dragger, SoTranslate2Dragger
*/
////////////////////////////////////////////////////////////////////////////////

public class SoTrackballDragger extends SoDragger {

    //SO_KIT_HEADER(SoTrackballDragger);
	private final SoSubKit kitHeader = SoSubKit.SO_KIT_HEADER(SoTrackballDragger.class,this);
	
	public                                                                     
    static SoType       getClassTypeId()        /* Returns class type id */   
                                    { return SoSubNode.getClassTypeId(SoTrackballDragger.class); }                   
    public SoType      getTypeId()       /* Returns type id      */
    {
		return kitHeader == null ? super.getTypeId() : kitHeader.getClassTypeId();		    	
    }
  public                                                                  
    SoFieldData   getFieldData() {
	  return kitHeader == null ? super.getFieldData() : kitHeader.getFieldData(); 
  }
  public  static SoFieldData[] getFieldDataPtr()                              
        { return SoSubNode.getFieldDataPtr(SoTrackballDragger.class); }              

	
    /* Returns an SoNodekitCatalog for the node */                            
    public SoNodekitCatalog getNodekitCatalog() {
    	if(kitHeader == null) {
    		return super.getNodekitCatalog();
    	}
    	return kitHeader.getNodekitCatalog();
    }

    //! For making the dragger surround what lies above it.
    protected final SoSFNode surroundScale = new SoSFNode();
    //! For keeping the dragger even size in all 3 dimensions
    protected final SoSFNode antiSquish = new SoSFNode();

    protected final SoSFNode rotatorSwitch = new SoSFNode();
    protected final SoSFNode rotator = new SoSFNode();
    protected final SoSFNode rotatorActive = new SoSFNode();
    protected final SoSFNode XRotatorSwitch = new SoSFNode();
    protected final SoSFNode XRotator = new SoSFNode();
    protected final SoSFNode XRotatorActive = new SoSFNode();
    protected final SoSFNode YRotatorSwitch = new SoSFNode();
    protected final SoSFNode YRotator = new SoSFNode();
    protected final SoSFNode YRotatorActive = new SoSFNode();
    protected final SoSFNode ZRotatorSwitch = new SoSFNode();
    protected final SoSFNode ZRotator = new SoSFNode();
    protected final SoSFNode ZRotatorActive = new SoSFNode();

    //! The userAxisRotation is not a public part.
    protected final SoSFNode userAxisRotation = new SoSFNode();

    protected final SoSFNode userAxisSwitch = new SoSFNode();
    protected final SoSFNode userAxis = new SoSFNode();
    protected final SoSFNode userAxisActive = new SoSFNode();
    protected final SoSFNode userRotatorSwitch = new SoSFNode();
    protected final SoSFNode userRotator = new SoSFNode();
    protected final SoSFNode userRotatorActive = new SoSFNode();
    



    public final SoSFRotation rotation = new SoSFRotation();
    public final SoSFVec3f scaleFactor = new SoSFVec3f();

    //! \see setAnimationEnabled
    public boolean isAnimationEnabled() { return animationEnabled; }
    //! If the mouse is moving while you release it, the
    //! trackball will continue to spin afterwards.  
    //! These two methods will query and set whether this 
    //! feature is turned on or off.  By default, the animation feature is turned on.

    
    protected SoFieldSensor rotFieldSensor;
    protected SoFieldSensor scaleFieldSensor;


    // Results of refactoring (MMS Bug: 57374): 

    //! Moved variables from private to protected
    protected SbSphereProjector   sphereProj;
    protected SbCylinderProjector stripeProj;

    protected boolean                ctlDown, shftDown; //!< keep track of meta keys

    enum State
        { INACTIVE, FREE_ROTATE, X_ROTATE, Y_ROTATE, Z_ROTATE,
          SCALE, USER_AXIS_ADJUST, USER_AXIS_ROTATE, SPINNING };
    protected State               currentState;

    private final SbVec3f             constrainedAxis = new SbVec3f();   //!< For storing the rotation axis
    private final SbVec3f             userAxisVec = new SbVec3f();       //!< For storing the user definable
                                           //! 'special' rotation axis.
    
    private final SbVec3f             startWorldHitPt = new SbVec3f();   //!< used during interaction
    private final SbVec3f             prevWorldHitPt = new SbVec3f();    //!< used during interaction by 
                                           //! spherical projector.
    private final SbMatrix            prevMotionMatrix = new SbMatrix();  //!< used during interaction by
                                           //! spherical projector.
    
    //! character strings from which the shared geometry is read
    private static short[] geomBuffer;             
    
    static {
    	int[] geom1 = getGeom1();
    	int length = geom1.length;
    	geomBuffer = new short[length];
    	for(int i=0; i<length; i++) {
    		if(i<length)
    			geomBuffer[i] = (short)geom1[i];
    	}    	
    }
    
    private static int[] getGeom1() {
    	int[] geom1 = {
    	0x23,0x49,0x6e,0x76,0x65,0x6e,0x74,0x6f,0x72,0x20,0x56,0x32,0x2e,0x31,0x20,0x62,0x69,0x6e,0x61,0x72,0x79,0x20,0x20,0xa,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x15,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x2d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x43,0x4f,0x4f,0x52,0x44,0x53,0x5f,0x41,0x4e,0x44,0x5f,0x4e,0x4f,0x52,0x4d,0x41,0x4c,0x53,0x2b,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0xd,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x50,0x45,0x52,0x5f,0x56,0x45,0x52,0x54,0x45,0x58,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x4f,0x56,0x45,0x52,0x41,0x4c,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x43,0x6f,0x6f,0x72,0x64,0x69,0x6e,0x61,0x74,0x65,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x70,0x6f,0x69,0x6e,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0x3d,0x4c,0xcc,0xcd,0x3e,0x47,0xc5,0xac,0x3f,0x7b,0x14,0xba,0xbd,0x4c,0xcc,0xcd,0x3e,0x47,0xc5,0xac,0x3f,0x6c,0x83,0x66,0x3d,0x4c,0xcc,0xcd,0x3e,0xc3,0xef,0x7,0x3f,0x6c,0x83,0x66,0xbd,0x4c,0xcc,0xcd,0x3e,0xc3,0xef,0x7,0x3f,0x54,0xdb,0x38,0x3d,0x4c,0xcc,0xcd,0x3f,0xe,0x39,0xd6,0x3f,0x54,0xdb,0x38,0xbd,0x4c,0xcc,0xcd,0x3f,0xe,0x39,0xd6,0x3f,0x35,0x4,0xf7,0x3d,0x4c,0xcc,0xcd,0x3f,0x35,0x4,0xf7,0x3f,0x35,0x4,0xf7,0xbd,0x4c,0xcc,0xcd,0x3f,0x35,0x4,0xf7,0x3f,0xe,0x39,0xd6,0x3d,0x4c,0xcc,0xcd,0x3f,0x54,0xdb,0x38,0x3f,0xe,0x39,0xd6,0xbd,0x4c,0xcc,0xcd,0x3f,0x54,0xdb,0x38,0x3e,0xc3,0xef,0x7,0x3d,0x4c,0xcc,0xcd,0x3f,0x6c,0x83,0x66,0x3e,0xc3,0xef,0x7,0xbd,0x4c,0xcc,0xcd,0x3f,0x6c,0x83,0x66,0x3e,0x47,0xc5,0xac,0x3d,0x4c,0xcc,0xcd,0x3f,0x7b,0x14,0xba,0x3e,0x47,0xc5,0xac,0xbd,0x4c,0xcc,0xcd,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x80,0x0,0x0,0xbe,0x47,0xc5,0xac,0x3d,0x4c,0xcc,0xcd,0x3f,0x7b,0x14,0xba,0xbe,0x47,0xc5,0xac,0xbd,0x4c,0xcc,0xcd,0x3f,0x7b,0x14,0xba,0xbe,0xc3,0xef,0x7,0x3d,0x4c,0xcc,0xcd,0x3f,0x6c,0x83,0x66,0xbe,0xc3,0xef,0x7,0xbd,0x4c,0xcc,0xcd,0x3f,0x6c,0x83,0x66,0xbf,0xe,0x39,0xd6,0x3d,0x4c,0xcc,0xcd,0x3f,0x54,0xdb,0x38,0xbf,0xe,0x39,0xd6,0xbd,0x4c,0xcc,0xcd,0x3f,0x54,0xdb,0x38,0xbf,0x35,0x4,0xf7,0x3d,0x4c,0xcc,0xcd,0x3f,0x35,0x4,0xf7,0xbf,0x35,0x4,0xf7,0xbd,0x4c,0xcc,0xcd,0x3f,0x35,0x4,0xf7,0xbf,0x54,0xdb,0x38,0x3d,0x4c,0xcc,0xcd,0x3f,0xe,0x39,0xd6,0xbf,0x54,0xdb,0x38,0xbd,0x4c,0xcc,0xcd,0x3f,0xe,0x39,0xd6,0xbf,0x6c,0x83,0x66,0x3d,0x4c,0xcc,0xcd,0x3e,0xc3,0xef,0x7,0xbf,0x6c,0x83,0x66,0xbd,0x4c,0xcc,0xcd,0x3e,0xc3,0xef,0x7,0xbf,0x7b,0x14,0xba,0x3d,0x4c,0xcc,0xcd,0x3e,0x47,0xc5,0xac,0xbf,0x7b,0x14,0xba,0xbd,0x4c,0xcc,0xcd,0x3e,0x47,0xc5,0xac,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0x3d,0x4c,0xcc,0xcd,0xbe,0x47,0xc5,0xac,0xbf,0x7b,0x14,0xba,0xbd,0x4c,0xcc,0xcd,0xbe,0x47,0xc5,0xac,0xbf,0x6c,0x83,0x66,0x3d,0x4c,0xcc,0xcd,0xbe,0xc3,0xef,0x7,0xbf,0x6c,0x83,0x66,0xbd,0x4c,0xcc,0xcd,0xbe,0xc3,0xef,0x7,0xbf,0x54,0xdb,0x38,0x3d,0x4c,0xcc,0xcd,0xbf,0xe,0x39,0xd6,0xbf,0x54,0xdb,0x38,0xbd,0x4c,0xcc,0xcd,0xbf,0xe,0x39,0xd6,0xbf,0x35,0x4,0xf7,0x3d,0x4c,0xcc,0xcd,0xbf,0x35,0x4,0xf7,0xbf,0x35,0x4,0xf7,0xbd,0x4c,0xcc,0xcd,0xbf,0x35,0x4,0xf7,0xbf,0xe,0x39,0xd6,0x3d,0x4c,0xcc,0xcd,0xbf,0x54,0xdb,0x38,0xbf,0xe,0x39,0xd6,0xbd,0x4c,0xcc,0xcd,0xbf,0x54,0xdb,0x38,0xbe,0xc3,0xef,0x7,0x3d,0x4c,0xcc,0xcd,0xbf,0x6c,0x83,0x66,0xbe,0xc3,0xef,0x7,0xbd,0x4c,0xcc,0xcd,0xbf,0x6c,0x83,0x66,0xbe,0x47,0xc5,0xac,0x3d,0x4c,0xcc,0xcd,0xbf,0x7b,0x14,0xba,0xbe,0x47,0xc5,0xac,0xbd,0x4c,0xcc,0xcd,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x3e,0x47,0xc5,0xac,0x3d,0x4c,0xcc,0xcd,0xbf,0x7b,0x14,0xba,0x3e,0x47,0xc5,0xac,0xbd,0x4c,0xcc,0xcd,0xbf,0x7b,0x14,0xba,0x3e,0xc3,0xef,0x7,0x3d,0x4c,0xcc,0xcd,0xbf,0x6c,0x83,0x66,0x3e,0xc3,0xef,0x7,0xbd,0x4c,0xcc,0xcd,0xbf,0x6c,0x83,0x66,0x3f,0xe,0x39,0xd6,0x3d,0x4c,0xcc,0xcd,0xbf,0x54,0xdb,0x38,0x3f,0xe,0x39,0xd6,0xbd,0x4c,0xcc,0xcd,0xbf,0x54,0xdb,0x38,0x3f,0x35,0x4,0xf7,0x3d,0x4c,0xcc,0xcd,0xbf,0x35,0x4,0xf7,0x3f,0x35,0x4,0xf7,0xbd,0x4c,0xcc,0xcd,0xbf,0x35,0x4,0xf7,0x3f,0x54,0xdb,0x38,0x3d,0x4c,0xcc,0xcd,0xbf,0xe,0x39,0xd6,0x3f,0x54,0xdb,0x38,0xbd,0x4c,0xcc,0xcd,0xbf,0xe,0x39,0xd6,0x3f,0x6c,0x83,0x66,0x3d,0x4c,0xcc,0xcd,0xbe,0xc3,0xef,0x7,0x3f,0x6c,0x83,0x66,0xbd,0x4c,0xcc,0xcd,0xbe,0xc3,0xef,0x7,0x3f,0x7b,0x14,0xba,0x3d,0x4c,0xcc,0xcd,0xbe,0x47,0xc5,0xac,0x3f,0x7b,0x14,0xba,0xbd,0x4c,0xcc,0xcd,0xbe,0x47,0xc5,0xac,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x6,0x76,0x65,0x63,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x40,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x3e,0x47,0xc5,0xac,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x3e,0x47,0xc5,0xac,0x3f,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0x3e,0xc3,0xef,0x7,0x3f,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0x3e,0xc3,0xef,0x7,0x3f,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0x3f,0xe,0x39,0xd6,0x3f,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0x3f,0xe,0x39,0xd6,0x3f,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0x3f,0x35,0x4,0xf7,0x3f,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0x3f,0x35,0x4,0xf7,0x3f,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0x3f,0x54,0xdb,0x38,0x3f,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0x3f,0x54,0xdb,0x38,0x3e,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0x3f,0x6c,0x83,0x66,0x3e,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0x3f,0x6c,0x83,0x66,0x3e,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0x3e,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0x80,0x0,0x0,0xbe,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0xbe,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0x3f,0x7b,0x14,0xba,0xbe,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0x3f,0x6c,0x83,0x66,0xbe,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0x3f,0x6c,0x83,0x66,0xbf,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0x3f,0x54,0xdb,0x38,0xbf,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0x3f,0x54,0xdb,0x38,0xbf,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0x3f,0x35,0x4,0xf7,0xbf,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0x3f,0x35,0x4,0xf7,0xbf,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0x3f,0xe,0x39,0xd6,0xbf,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0x3f,0xe,0x39,0xd6,0xbf,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0x3e,0xc3,0xef,0x7,0xbf,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0x3e,0xc3,0xef,0x7,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x3e,0x47,0xc5,0xac,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x3e,0x47,0xc5,0xac,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0xbe,0x47,0xc5,0xac,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0xbe,0x47,0xc5,0xac,0xbf,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0xbe,0xc3,0xef,0x7,0xbf,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0xbe,0xc3,0xef,0x7,0xbf,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0xbf,0xe,0x39,0xd6,0xbf,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0xbf,0xe,0x39,0xd6,0xbf,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0xbf,0x35,0x4,0xf7,0xbf,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0xbf,0x35,0x4,0xf7,0xbf,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0xbf,0x54,0xdb,0x38,0xbf,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0xbf,0x54,0xdb,0x38,0xbe,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0xbf,0x6c,0x83,0x66,0xbe,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0xbf,0x6c,0x83,0x66,0xbe,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0xbe,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbf,0x80,0x0,0x0,0x3e,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0x3e,0x47,0xc5,0xac,0x0,0x0,0x0,0x0,0xbf,0x7b,0x14,0xba,0x3e,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0xbf,0x6c,0x83,0x66,0x3e,0xc3,0xef,0x7,0x0,0x0,0x0,0x0,0xbf,0x6c,0x83,0x66,0x3f,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0xbf,0x54,0xdb,0x38,0x3f,0xe,0x39,0xd6,0x0,0x0,0x0,0x0,0xbf,0x54,0xdb,0x38,0x3f,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0xbf,0x35,0x4,0xf7,0x3f,0x35,0x4,0xf7,0x0,0x0,0x0,0x0,0xbf,0x35,0x4,0xf7,0x3f,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0xbf,0xe,0x39,0xd6,0x3f,0x54,0xdb,0x38,0x0,0x0,0x0,0x0,0xbf,0xe,0x39,0xd6,0x3f,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0xbe,0xc3,0xef,0x7,0x3f,0x6c,0x83,0x66,0x0,0x0,0x0,0x0,0xbe,0xc3,0xef,0x7,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0xbe,0x47,0xc5,0xac,0x3f,0x7b,0x14,0xba,0x0,0x0,0x0,0x0,0xbe,0x47,0xc5,0xac,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x23,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x4d,0x45,0x53,0x48,0x2b,0x31,0x0,0x0,0x0,0x0,0x10,0x54,0x72,0x69,0x61,0x6e,0x67,0x6c,0x65,0x53,0x74,0x72,0x69,0x70,0x53,0x65,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x6e,0x75,0x6d,0x56,0x65,0x72,0x74,0x69,0x63,0x65,0x73,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x28,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x2b,0x32,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x23,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x4d,0x45,0x53,0x48,0x2b,0x31,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x31,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x5f,0x4f,0x55,0x54,0x4c,0x49,0x4e,0x45,0x2b,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x9,0x50,0x69,0x63,0x6b,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x12,0x50,0x45,0x52,0x5f,0x56,0x45,0x52,0x54,0x45,0x58,0x5f,0x49,0x4e,0x44,0x45,0x58,0x45,0x44,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x4f,0x56,0x45,0x52,0x41,0x4c,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x49,0x6e,0x64,0x65,0x78,0x65,0x64,0x4c,0x69,0x6e,0x65,0x53,0x65,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa,0x63,0x6f,0x6f,0x72,0x64,0x49,0x6e,0x64,0x65,0x78,0x0,0x0,0x0,0x0,0x0,0x48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x9,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0xd,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xa,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x11,0x0,0x0,0x0,0x13,0x0,0x0,0x0,0x15,0x0,0x0,0x0,0x17,0x0,0x0,0x0,0x19,0x0,0x0,0x0,0x1b,0x0,0x0,0x0,0x1d,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x1e,0x0,0x0,0x0,0x1c,0x0,0x0,0x0,0x1a,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x16,0x0,0x0,0x0,0x14,0x0,0x0,0x0,0x12,0x0,0x0,0x0,0x10,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x21,0x0,0x0,0x0,0x23,0x0,0x0,0x0,0x25,0x0,0x0,0x0,0x27,0x0,0x0,0x0,0x29,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x2d,0x0,0x0,0x0,0x2f,0x0,0x0,0x0,0x2e,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x2a,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x26,0x0,0x0,0x0,0x24,0x0,0x0,0x0,0x22,0x0,0x0,0x0,0x20,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x31,0x0,0x0,0x0,0x33,0x0,0x0,0x0,0x35,0x0,0x0,0x0,0x37,0x0,0x0,0x0,0x39,0x0,0x0,0x0,0x3b,0x0,0x0,0x0,0x3d,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3e,0x0,0x0,0x0,0x3c,0x0,0x0,0x0,0x3a,0x0,0x0,0x0,0x38,0x0,0x0,0x0,0x36,0x0,0x0,0x0,0x34,0x0,0x0,0x0,0x32,0x0,0x0,0x0,0x30,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x58,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x34,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x53,0x63,0x61,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x73,0x63,0x61,0x6c,0x65,0x46,0x61,0x63,0x74,0x6f,0x72,0x0,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x52,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x58,0x59,0x5a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x4,0x61,0x78,0x69,0x73,0x0,0x0,0x0,0x1,0x5a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x61,0x6e,0x67,0x6c,0x65,0x0,0x0,0x0,0x3f,0xc9,0xf,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x2d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x43,0x4f,0x4f,0x52,0x44,0x53,0x5f,0x41,0x4e,0x44,0x5f,0x4e,0x4f,0x52,0x4d,0x41,0x4c,0x53,0x2b,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x28,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x2b,0x32,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x31,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x5f,0x4f,0x55,0x54,0x4c,0x49,0x4e,0x45,0x2b,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x35,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x53,0x63,0x61,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x73,0x63,0x61,0x6c,0x65,0x46,0x61,0x63,0x74,0x6f,0x72,0x0,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x2d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x43,0x4f,0x4f,0x52,0x44,0x53,0x5f,0x41,0x4e,0x44,0x5f,0x4e,0x4f,0x52,0x4d,0x41,0x4c,0x53,0x2b,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x28,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x2b,0x32,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x31,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x5f,0x4f,0x55,0x54,0x4c,0x49,0x4e,0x45,0x2b,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x5a,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x36,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x53,0x63,0x61,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x73,0x63,0x61,0x6c,0x65,0x46,0x61,0x63,0x74,0x6f,0x72,0x0,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x3f,0x84,0xdd,0x2f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x52,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x58,0x59,0x5a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x4,0x61,0x78,0x69,0x73,0x0,0x0,0x0,0x1,0x58,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x61,0x6e,0x67,0x6c,0x65,0x0,0x0,0x0,0x3f,0xc9,0xf,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x2d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x43,0x4f,0x4f,0x52,0x44,0x53,0x5f,0x41,0x4e,0x44,0x5f,0x4e,0x4f,0x52,0x4d,0x41,0x4c,0x53,0x2b,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x28,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x2b,0x32,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x31,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x5f,0x4f,0x55,0x54,0x4c,0x49,0x4e,0x45,0x2b,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x41,0x58,0x49,0x53,0x2b,0x37,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x53,0x63,0x61,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x73,0x63,0x61,0x6c,0x65,0x46,0x61,0x63,0x74,0x6f,0x72,0x0,0x3f,0x8b,0x43,0x96,0x3f,0x8b,0x43,0x96,0x3f,0x8b,0x43,0x96,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x12,0x50,0x45,0x52,0x5f,0x56,0x45,0x52,0x54,0x45,0x58,0x5f,0x49,0x4e,0x44,0x45,0x58,0x45,0x44,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x42,0x69,0x6e,0x64,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x4f,0x56,0x45,0x52,0x41,0x4c,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x43,0x6f,0x6f,0x72,0x64,0x69,0x6e,0x61,0x74,0x65,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x70,0x6f,0x69,0x6e,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0xbf,0xa0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xa0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x4c,0x69,0x6e,0x65,0x53,0x65,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x20,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x38,0x0,0x0,0x0,0x5,0x47,0x72,0x6f,0x75,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x53,0x63,0x61,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xb,0x73,0x63,0x61,0x6c,0x65,0x46,0x61,0x63,0x74,0x6f,0x72,0x0,0x3f,0x8b,0x43,0x96,0x3f,0x8b,0x43,0x96,0x3f,0x8b,0x43,0x96,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x2d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x43,0x4f,0x4f,0x52,0x44,0x53,0x5f,0x41,0x4e,0x44,0x5f,0x4e,0x4f,0x52,0x4d,0x41,0x4c,0x53,0x2b,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x23,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x4d,0x45,0x53,0x48,0x2b,0x31,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x31,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x52,0x49,0x4e,0x47,0x5f,0x53,0x48,0x41,0x50,0x45,0x5f,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x5f,0x4f,0x55,0x54,0x4c,0x49,0x4e,0x45,0x2b,0x33,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x10,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x43,0x6f,0x6d,0x70,0x6c,0x65,0x78,0x69,0x74,0x79,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x3e,0x99,0x99,0x9a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x53,0x70,0x68,0x65,0x72,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x6,0x72,0x61,0x64,0x69,0x75,0x73,0x0,0x0,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x16,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x49,0x4e,0x56,0x49,0x53,0x49,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x43,0x6f,0x6d,0x70,0x6c,0x65,0x78,0x69,0x74,0x79,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x76,0x61,0x6c,0x75,0x65,0x0,0x0,0x0,0x3e,0x99,0x99,0x9a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x53,0x70,0x68,0x65,0x72,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x6,0x72,0x61,0x64,0x69,0x75,0x73,0x0,0x0,0x3f,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x11,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x58,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x58,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x34,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x17,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x58,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x58,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x34,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x11,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x59,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x35,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x17,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x59,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x59,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x35,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x11,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x5a,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x5a,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x36,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x17,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x5a,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x5a,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x36,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x11,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x55,0x73,0x65,0x72,0x41,0x78,0x69,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x9,0x50,0x69,0x63,0x6b,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3e,0x80,0x0,0x0,0x3d,0x4c,0xcc,0xcd,0x3e,0xb8,0x51,0xec,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3e,0x80,0x0,0x0,0x3d,0x4c,0xcc,0xcd,0x3e,0xb8,0x51,0xec,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x41,0x58,0x49,0x53,0x2b,0x37,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x17,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x55,0x73,0x65,0x72,0x41,0x78,0x69,0x73,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x9,0x50,0x69,0x63,0x6b,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x73,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x55,0x4e,0x50,0x49,0x43,0x4b,0x41,0x42,0x4c,0x45,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3e,0xb8,0x51,0xec,0x3d,0x4c,0xcc,0xcd,0x3e,0xe1,0x47,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3e,0xb8,0x51,0xec,0x3d,0x4c,0xcc,0xcd,0x3e,0xe1,0x47,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x1d,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x41,0x58,0x49,0x53,0x2b,0x37,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x14,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x55,0x73,0x65,0x72,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3d,0x4c,0xcc,0xcd,0x3e,0x38,0x51,0xec,0x3e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3d,0x4c,0xcc,0xcd,0x3e,0x38,0x51,0xec,0x3e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x74,0x72,0x61,0x6e,0x73,0x70,0x61,0x72,0x65,0x6e,0x63,0x79,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x20,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x38,0x0,0x0,0x0,0x3,0x44,0x45,0x46,0x0,0x0,0x0,0x0,0x1a,0x74,0x72,0x61,0x63,0x6b,0x62,0x61,0x6c,0x6c,0x55,0x73,0x65,0x72,0x52,0x6f,0x74,0x61,0x74,0x6f,0x72,0x41,0x63,0x74,0x69,0x76,0x65,0x0,0x0,0x0,0x0,0x0,0x9,0x53,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xd,0x72,0x65,0x6e,0x64,0x65,0x72,0x43,0x61,0x63,0x68,0x69,0x6e,0x67,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4f,0x4e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x4d,0x61,0x74,0x65,0x72,0x69,0x61,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0xc,0x64,0x69,0x66,0x66,0x75,0x73,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x1,0x3d,0x4c,0xcc,0xcd,0x3e,0x4f,0x5c,0x29,0x3e,0x38,0x51,0xec,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd,0x65,0x6d,0x69,0x73,0x73,0x69,0x76,0x65,0x43,0x6f,0x6c,0x6f,0x72,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x3d,0x4c,0xcc,0xcd,0x3e,0x4f,0x5c,0x29,0x3e,0x38,0x51,0xec,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x74,0x72,0x61,0x6e,0x73,0x70,0x61,0x72,0x65,0x6e,0x63,0x79,0x0,0x0,0x0,0x1,0x3f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x44,0x72,0x61,0x77,0x53,0x74,0x79,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x9,0x6c,0x69,0x6e,0x65,0x57,0x69,0x64,0x74,0x68,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x4c,0x69,0x67,0x68,0x74,0x4d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x5,0x6d,0x6f,0x64,0x65,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0x50,0x48,0x4f,0x4e,0x47,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x55,0x53,0x45,0x0,0x0,0x0,0x0,0x20,0x54,0x52,0x41,0x43,0x4b,0x42,0x41,0x4c,0x4c,0x5f,0x44,0x52,0x41,0x47,0x47,0x45,0x52,0x5f,0x55,0x53,0x45,0x52,0x5f,0x52,0x4f,0x54,0x41,0x54,0x4f,0x52,0x2b,0x38
    	};
    	return geom1;
    }

    //! variables used for doing spinning animation
    private boolean animationEnabled;
    private final SbTime          prevTime = new SbTime();
    private final SbTime          spinTime = new SbTime();
    private final SbTime          scheduleRate = new SbTime();
    private SoTimerSensor   spinSensor;
    private SbRotation[]      rotBuffer;
    private SbTime[]          timeBuffer;
    private int             firstIndex, lastIndex;
    private final SbVec3f         averageAxis = new SbVec3f();
    private float           angleVelocity;
    private boolean            computeAverage;

    //! We record whether ball was spinning at drag start. If so, it will 
    //! call ha.setHandled() in dragFinish().  This way, it won't be 
    //! considered an item selection, which is usually the case when you click 
    //! on an object without moving the mouse.
    private boolean    wasSpinningAtDragStart;
    

// Defines

private static final float FAST_ANIM_RATE =(1/60.0f);    // animation frame rate
private static final float ANIM_ADJUSTMENT =0.05f;       // used to schedule timerSensor to take 
                                   // a little more or a little less time.

// size of the rotation buffer, which is used to animate the spinning ball.
private final static int ROT_BUFFER_SIZE =5;

//SO_KIT_SOURCE(SoTrackballDragger);

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Constructor
//
public SoTrackballDragger()
//
////////////////////////////////////////////////////////////////////////
{
    kitHeader.SO_KIT_CONSTRUCTOR(SoTrackballDragger.class);

    isBuiltIn = true;

    // Don't create this by default. It's only really put into use
    // if this dragger is put inside a manipulator.
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(surroundScale,"surroundScale", SoSurroundScale.class, 
                                true, "topSeparator", "geomSeparator",true);
    // Create an anti-squish node by default.
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(antiSquish,"antiSquish", SoAntiSquish.class, 
                                false, "topSeparator", "geomSeparator",true);

    // Put this stuff under the geomSeparator so it will draw more
    // efficiently.
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(rotatorSwitch,"rotatorSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(rotator,"rotator", SoSeparator.class, true,
                                "rotatorSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(rotatorActive,"rotatorActive", SoSeparator.class, true,
                                "rotatorSwitch","",true);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(XRotatorSwitch,"XRotatorSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(XRotator,"XRotator", SoSeparator.class, true,
                                "XRotatorSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(XRotatorActive,"XRotatorActive", SoSeparator.class, true,
                                "XRotatorSwitch","",true);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(YRotatorSwitch,"YRotatorSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(YRotator,"YRotator", SoSeparator.class, true,
                                "YRotatorSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(YRotatorActive,"YRotatorActive", SoSeparator.class, true,
                                "YRotatorSwitch","",true);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(ZRotatorSwitch,"ZRotatorSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(ZRotator,"ZRotator", SoSeparator.class, true,
                                "ZRotatorSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(ZRotatorActive,"ZRotatorActive", SoSeparator.class, true,
                                "ZRotatorSwitch","",true);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userAxisRotation,"userAxisRotation", SoRotation.class, true,
                                "geomSeparator","",false);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userAxisSwitch,"userAxisSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userAxis,"userAxis", SoSeparator.class, true,
                                "userAxisSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userAxisActive,"userAxisActive", SoSeparator.class, true,
                                "userAxisSwitch","",true);

    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userRotatorSwitch,"userRotatorSwitch", SoSwitch.class, true,
                                "geomSeparator","",false);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userRotator,"userRotator", SoSeparator.class, true,
                                "userRotatorSwitch","",true);
    kitHeader.SO_KIT_ADD_CATALOG_ENTRY(userRotatorActive,"userRotatorActive", SoSeparator.class, true,
                                "userRotatorSwitch","",true);

    // read geometry for shared parts
    if (kitHeader.SO_KIT_IS_FIRST_INSTANCE())
        readDefaultParts("trackballDragger.iv", geomBuffer, geomBuffer.length );

    kitHeader.SO_KIT_ADD_FIELD(rotation,"rotation", new SbRotation(0.0f, 0.0f, 0.0f, 1.0f));
    kitHeader.SO_KIT_ADD_FIELD(scaleFactor,"scaleFactor", new SbVec3f(1.0f, 1.0f, 1.0f));

    SO_KIT_INIT_INSTANCE();

    // Make the anti-squish node surround the biggest dimension
    SoAntiSquish as = (SoAntiSquish)/*SO_GET_ANY_PART( this,*/getAnyPart("antiSquish", true);// SoAntiSquish.class );
    as.sizing.setValue(SoAntiSquish.Sizing.LONGEST_DIAGONAL);

    // create the parts...
  setPartAsDefault("rotator",          "trackballRotator");
  setPartAsDefault("rotatorActive",    "trackballRotatorActive");
  setPartAsDefault("XRotator",         "trackballXRotator");
  setPartAsDefault("XRotatorActive",   "trackballXRotatorActive");
  setPartAsDefault("YRotator",         "trackballYRotator");
  setPartAsDefault("YRotatorActive",   "trackballYRotatorActive");
  setPartAsDefault("ZRotator",         "trackballZRotator");
  setPartAsDefault("ZRotatorActive",   "trackballZRotatorActive");
  setPartAsDefault("userAxis",         "trackballUserAxis");
  setPartAsDefault("userAxisActive",   "trackballUserAxisActive");
  setPartAsDefault("userRotator",      "trackballUserRotator");
  setPartAsDefault("userRotatorActive","trackballUserRotatorActive");

  // Set the switches of the ball and stripes to 0...
    setSwitchValue(  rotatorSwitch.getValue(), 0 );
    setSwitchValue( XRotatorSwitch.getValue(), 0 );
    setSwitchValue( YRotatorSwitch.getValue(), 0 );
    setSwitchValue( ZRotatorSwitch.getValue(), 0 );

  //Turn off userAxis Completely (SO_SWITCH_NONE)
    setSwitchValue(    userAxisSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );
    setSwitchValue( userRotatorSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );

  // Set the rotation of the userStuffRotation to an initial value.
    SoRotation rN = /*SO_GET_ANY_PART(this,*/(SoRotation)getAnyPart("userAxisRotation", /*SoRotation.class*/true);
    rN.rotation.setValue( new SbRotation( new SbVec3f(0,1,0), 0.0f ) );

    currentState = State.INACTIVE;

    setHighlights();

    // init the user axis to align with 'y'
    userAxisVec.setValue( 0, 1, 0);

    // queues used for animation
    rotBuffer =  new SbRotation[ROT_BUFFER_SIZE];
    timeBuffer = new SbTime[ROT_BUFFER_SIZE];
    for(int i=0; i<ROT_BUFFER_SIZE;i++) {
    	rotBuffer[i] = new SbRotation();
    	timeBuffer[i] = new SbTime();
    }

    // allocate animation sensor
    spinSensor = new SoTimerSensor(SoTrackballDragger::spinSensorCB, this);

    animationEnabled = false;
    wasSpinningAtDragStart = false;

    sphereProj = new SbSphereSectionProjector( 0.85f );
    stripeProj = new SbCylinderPlaneProjector( 0.85f );

    // add the callbacks to perform the dragging
    addStartCallback(  SoTrackballDragger::startCB );
    addMotionCallback( SoTrackballDragger::motionCB );
    addFinishCallback(   SoTrackballDragger::finishCB );

    // add the callback to update things each time a meta key changes.
    addOtherEventCallback( SoTrackballDragger::metaKeyChangeCB );

    // Update the rotation and scale fields when the motionMatrix is set.
    addValueChangedCallback( SoTrackballDragger::valueChangedCB );

    // Updates the motionMatrix when the scaleFactor field is set.
    rotFieldSensor = new SoFieldSensor(SoTrackballDragger::fieldSensorCB,this);
    rotFieldSensor.setPriority( 0 );

    // Updates the motionMatrix when the scaleFactor field is set.
    scaleFieldSensor 
        = new SoFieldSensor( SoTrackballDragger::fieldSensorCB, this);
    scaleFieldSensor.setPriority( 0 );

    setUpConnections( true, true );
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Destructor.
//
// Use: public

public void destructor()
//
////////////////////////////////////////////////////////////////////////
{
    // deallocate queues
    //delete [ /*ROT_BUFFER_SIZE*/ ] rotBuffer; java port
    //delete [ /*ROT_BUFFER_SIZE*/ ] timeBuffer; java port

    sphereProj.destructor();
    stripeProj.destructor();

    // delete sensors
    if (spinSensor != null)
        spinSensor.destructor();
    if (rotFieldSensor != null)
        rotFieldSensor.destructor();
    if (scaleFieldSensor != null)
        scaleFieldSensor.destructor();
    super.destructor();
}

//    detach/attach any sensors, callbacks, and/or field connections.
//    Called by:            start/end of SoBaseKit.readInstance
//    and on new copy by:   start/end of SoBaseKit.copy.
//    Classes that redefine must call setUpConnections(true,true) 
//    at end of constructor.
//    Returns the state of the node when this was called.
public boolean
setUpConnections( boolean onOff, boolean doItAlways )
{
	if(kitHeader == null) {// java port
		return super.setUpConnections(onOff, doItAlways);
	}
	
	
    if ( !doItAlways && connectionsSetUp == onOff)
        return onOff;

    if ( onOff ) {

        // We connect AFTER base class.
        super.setUpConnections( onOff, false );

        // Call the sensor CBs to make things are up-to-date.
        fieldSensorCB( this, null );

        // Figure out the userAxisVec (a protected variable) from the 
        // 'userAxisRotation' part.
        SoRotation rN = (SoRotation ) userAxisRotation.getValue();
        if (rN != null) {
            SbRotation uRot = new SbRotation(rN.rotation.getValue());
            uRot.multVec( new SbVec3f(0,1,0), userAxisVec );

            // decide whether or not to display the spinning wheel.
            // only show it if does not line up with a major axis.
            if (   ( Math.abs(userAxisVec.getValueRead()[0]) > 0.99 )
                || ( Math.abs(userAxisVec.getValueRead()[1]) > 0.99 )
                || ( Math.abs(userAxisVec.getValueRead()[2]) > 0.99 ) ) {
                setSwitchValue( userAxisSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );
                setSwitchValue( userRotatorSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );
            }
            else {
                setSwitchValue( userAxisSwitch.getValue(), 1 );
                setSwitchValue( userRotatorSwitch.getValue(), 1 );
            }
        }

        // Connect the field sensors
        if (rotFieldSensor.getAttachedField() != rotation)
            rotFieldSensor.attach( rotation );
        if (scaleFieldSensor.getAttachedField() != scaleFactor)
            scaleFieldSensor.attach( scaleFactor );
    }
    else {

        // We disconnect BEFORE base class.

        // Disconnect the field sensors.
        if (rotFieldSensor.getAttachedField()!=null)
            rotFieldSensor.detach();
        if (scaleFieldSensor.getAttachedField()!=null)
            scaleFieldSensor.detach();

        super.setUpConnections( onOff, false );
    }

    return !(connectionsSetUp = onOff);
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Destructor.
//
// Use: public
public void
setAnimationEnabled( boolean newVal )
//
////////////////////////////////////////////////////////////////////////
{
    animationEnabled = newVal;
    if (animationEnabled == false )
        resetSpinStuff();
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Sets the various switch nodes to highlight the correct parts
//    of the trackball, depending on the state.
//
// Use: private
//
private void
setHighlights()
//
////////////////////////////////////////////////////////////////////////
{
    switch ( currentState ) {
        case INACTIVE:
        case SPINNING:
            setAllPartsActive( false );
            break;
        case FREE_ROTATE:
        case SCALE:
            setAllPartsActive( true );
            break;
        case X_ROTATE:
            setAllPartsActive( false );
            setSwitchValue( XRotatorSwitch.getValue(), 1 );
            break;
        case Y_ROTATE:
            setAllPartsActive( false );
            setSwitchValue( YRotatorSwitch.getValue(), 1 );
            break;
        case Z_ROTATE:
            setAllPartsActive( false );
            setSwitchValue( ZRotatorSwitch.getValue(), 1 );
            break;
        case USER_AXIS_ROTATE:
        case USER_AXIS_ADJUST:
            {
            setAllPartsActive( false );

            SoSwitch sw = (SoSwitch ) userAxisSwitch.getValue();
            if ( sw!= null && sw.whichChild.getValue() != SoSwitch.SO_SWITCH_NONE )
                setSwitchValue( userAxisSwitch.getValue(), 1 );

            sw = (SoSwitch ) userRotatorSwitch.getValue();
            if ( sw!=null && sw.whichChild.getValue() != SoSwitch.SO_SWITCH_NONE )
                setSwitchValue( userRotatorSwitch.getValue(), 1 );
            }
            break;
    }
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Rotate the trackball and object based on mouse motion.
//
// Use: private
//
private void
dragStart()
//
////////////////////////////////////////////////////////////////////////
{
    // register time for animation of continuous spinning
    prevTime.copyFrom( getEvent().getTime()); 

    // We want to remember if we were spinning at drag start.
    // If so, we will always call ha.setHandled() in dragFinish().
    // This way, it won't be considered an item selection, which is usually
    // the case when you click on an object without moving the mouse.
    wasSpinningAtDragStart = (currentState == State.SPINNING);
    resetSpinStuff();     // check if spinning should be stopped

    // Invalidate surroundScale if it exists.
    SoSurroundScale ss = (SoSurroundScale)SoBaseKit.SO_CHECK_PART(this, "surroundScale", SoSurroundScale.class);
    if (ss != null)
        ss.invalidate();

    // Make a note of which modifier keys are down
    ctlDown = getEvent().wasCtrlDown();
    shftDown = getEvent().wasShiftDown();

    // Determine the current state 
    initDragState();

    // set the constrained axis, if appropriate
    switch( currentState ) {
        case X_ROTATE:
            constrainedAxis.setValue( 1, 0, 0);
            break;
        case Y_ROTATE:
            constrainedAxis.setValue( 0, 1, 0);
            break;
        case Z_ROTATE:
            constrainedAxis.setValue( 0, 0, 1);
            break;
        case USER_AXIS_ROTATE:
            constrainedAxis.copyFrom( userAxisVec);
            break;
    }

    // Working space is space after "antiSquish"
    final SbMatrix workSpaceToLocal = new SbMatrix(), localToWorkSpace = new SbMatrix();
    getPartToLocalMatrix( "antiSquish", workSpaceToLocal, localToWorkSpace);
    final SbMatrix worldSpaceToWork = new SbMatrix(getWorldToLocalMatrix());
    worldSpaceToWork.multRight( localToWorkSpace );
    final SbMatrix workSpaceToWorld = new SbMatrix(getLocalToWorldMatrix());
    workSpaceToWorld.multLeft( workSpaceToLocal );

    // Find the starting point in workspace.
    final SbVec3f startWorkSpaceHitPt = new SbVec3f();
    worldSpaceToWork.multVecMatrix(getWorldStartingPoint(),startWorkSpaceHitPt);


    float   rad;
    final SbVec3f zero = new SbVec3f( 0,0,0 );
    final SbLine  theAxis = new SbLine();
    rad = startWorkSpaceHitPt.length();


    // Setup projector and get a starting value
    switch( currentState ) {
        case SCALE:
        case USER_AXIS_ADJUST:
        case FREE_ROTATE:
            {
            final SbVec3f       sphCenter = new SbVec3f(0,0,0);

            // Refactoring (MMS Bug: 57374)
            // make sure that our internal projector gets initialized  
            initSphereProjectorInternal(new SbVec3f(0,0,0), rad, startWorkSpaceHitPt, workSpaceToWorld);
            // allow a derived class to have its own projector
            SbProjector  proj = initSphereProjector(new SbVec3f(0,0,0), rad, startWorkSpaceHitPt, workSpaceToWorld);
            
            // We need to project and save the starting world point, 
            // Since our rotate projectors might intersect to find a 
            // different point than we hit on the geometry itself.
            final SbVec3f ptOnProjector = new SbVec3f(), worldSpacePt = new SbVec3f();

            // Refactoring (MMS Bug: 57374)
            ptOnProjector.copyFrom( proj.project(getNormalizedLocaterPosition()));

            workSpaceToWorld.multVecMatrix(ptOnProjector,worldSpacePt);
            setStartingPoint(worldSpacePt);
            }
            break;
        case X_ROTATE:
        case Y_ROTATE:
        case Z_ROTATE:
        case USER_AXIS_ROTATE:
            {
            theAxis.setValue( zero, zero.operator_add( constrainedAxis) );

            // Refactoring (MMS Bug: 57374)
            // make sure that our internal projector gets initialized  
            initStripeProjectorInternal(theAxis, rad, startWorkSpaceHitPt, workSpaceToWorld);
            // allow a derived class to have its own projector
            SbProjector  proj = initStripeProjector(theAxis, rad, startWorkSpaceHitPt, workSpaceToWorld);

            // We need to project and save the starting world point, 
            // Since our rotate projectors might intersect to find a 
            // different point than we hit on the geometry itself.
            final SbVec3f ptOnProjector = new SbVec3f(), worldSpacePt = new SbVec3f();

            // Refactoring (MMS Bug: 57374)
            ptOnProjector.copyFrom( proj.project(getNormalizedLocaterPosition()));

            workSpaceToWorld.multVecMatrix(ptOnProjector,worldSpacePt);
            setStartingPoint(worldSpacePt);
            }
            break;
        case INACTIVE:
        case SPINNING:
            break;
    }

    // Save for incremental rotations, needed by spherical projector.
    prevWorldHitPt.copyFrom( getWorldStartingPoint());
    prevMotionMatrix.copyFrom( getStartMotionMatrix());

    if ( currentState == State.USER_AXIS_ADJUST )
        userStripeDrag();

    setHighlights();
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Determines the State based on the current pick path.
//    Result of refactoring (MMS Bug: 57374)
//
// Use: protected
//
protected void 
initDragState()
{
  // This code block was implemented in dragStart() originally

  // Determine the current state
  final SoPath pickPath = getPickPath();
  if (ctlDown)
      currentState = State.SCALE;
  else if (shftDown)
      currentState = State.USER_AXIS_ADJUST;
  else if (pickPath!=null && pickPath.containsNode( XRotatorSwitch.getValue()  ) ||
            getSurrogatePartPickedName().operator_equal_equal("XRotator") )
      currentState = State.X_ROTATE;
  else if (pickPath!=null && pickPath.containsNode( YRotatorSwitch.getValue()  ) ||
            getSurrogatePartPickedName().operator_equal_equal("YRotator") )
      currentState = State.Y_ROTATE;
  else if (pickPath!=null && pickPath.containsNode( ZRotatorSwitch.getValue()  ) ||
            getSurrogatePartPickedName().operator_equal_equal("ZRotator") )
      currentState = State.Z_ROTATE;
  else if (pickPath!=null && pickPath.containsNode(userRotatorSwitch.getValue()) ||
            getSurrogatePartPickedName().operator_equal_equal("userRotator") )
      currentState = State.USER_AXIS_ROTATE;
  else 
      currentState = State.FREE_ROTATE;
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Setup the projector at start of free rotation.
//    Result of refactoring (MMS Bug: 57374)
//
public void initSphereProjectorInternal(SbVec3f center, float radius, SbVec3f startWorkSpaceHitPt, SbMatrix workingSpace)
{
  // This code block was implemented in dragStart() originally

  sphereProj.setSphere( new SbSphere( center, radius ));
  sphereProj.setViewVolume(getViewVolume() );
  sphereProj.setWorkingSpace( workingSpace );

  // If the hit point is on the near side of the center from where
  // the eye is, then tell the projector to intersect front.
  // Else, tell it to intersect back.
  if (getFrontOnProjector() ==  SoDragger.ProjectorFrontSetting.USE_PICK )
      sphereProj.setFront( sphereProj.isPointInFront( startWorkSpaceHitPt ));
  else if (getFrontOnProjector() ==  SoDragger.ProjectorFrontSetting.FRONT )
      sphereProj.setFront( true );
  else
      sphereProj.setFront( false );
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Setup the projector at start of free rotation.
//    Result of refactoring (MMS Bug: 57374)
//
public void initStripeProjectorInternal(SbLine axis, float radius, SbVec3f startWorkSpaceHitPt, SbMatrix workingSpace)
{
  // This code block was implemented in dragStart() originally

  stripeProj.setCylinder( new SbCylinder(axis, radius) );
  stripeProj.setViewVolume(getViewVolume());
  stripeProj.setWorkingSpace( workingSpace );

  // If the hit point is on the near side of the center from where
  // the eye is, then tell the projector to intersect front.
  // Else, tell it to intersect back.
  if (getFrontOnProjector() ==  SoDragger.ProjectorFrontSetting.USE_PICK )
      stripeProj.setFront( stripeProj.isPointInFront( startWorkSpaceHitPt));
  else if (getFrontOnProjector() ==  SoDragger.ProjectorFrontSetting.FRONT )
      stripeProj.setFront( true );
  else
      stripeProj.setFront( false );  
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Drag the trackball based on mouse motion.
//    This routine just ships the work to rotateDrag or
//    scaleDrag.
//
// Use: private
//
private void
drag()
//
////////////////////////////////////////////////////////////////////////
{
    switch( currentState ) {
        case SCALE:
            scaleDrag();
            break;
        case USER_AXIS_ADJUST:
            userStripeDrag();
            break;
        case FREE_ROTATE:
        case X_ROTATE:
        case Y_ROTATE:
        case Z_ROTATE:
        case USER_AXIS_ROTATE:
            rotateDrag();
            break;
        case INACTIVE:
        case SPINNING:
            break;
    }
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Rotate the trackball and object based on mouse motion.
//
// Use: private
//
private boolean
rotateDrag()
//
////////////////////////////////////////////////////////////////////////
{
    final SbMatrix workSpaceToLocal = new SbMatrix(), localToWorkSpace = new SbMatrix();
    getPartToLocalMatrix( "antiSquish", workSpaceToLocal, localToWorkSpace);
    final SbMatrix workSpaceToWorld = new SbMatrix(getLocalToWorldMatrix());
    workSpaceToWorld.multLeft( workSpaceToLocal );
    final SbMatrix worldSpaceToWork = new SbMatrix(getWorldToLocalMatrix());
    worldSpaceToWork.multRight( localToWorkSpace );

    // update the viewvolume and workspace on the projectors
    sphereProj.setViewVolume(getViewVolume());
    stripeProj.setViewVolume(getViewVolume());
    sphereProj.setWorkingSpace( workSpaceToWorld );
    stripeProj.setWorkingSpace( workSpaceToWorld );

    // Get newHitPt and prevHitPt in workspace.
    final SbVec3f     prevHitPt = new SbVec3f();
    worldSpaceToWork.multVecMatrix(prevWorldHitPt, prevHitPt );
    final SbVec3f     newHitPt = new SbVec3f();
    final SbRotation  deltaRot = new SbRotation();
    if ( currentState == State.FREE_ROTATE ) {
        getSphereDeltaRotation(deltaRot, newHitPt, prevHitPt, workSpaceToWorld);
    }
    else {
        getStripeDeltaRotation(deltaRot, newHitPt, prevHitPt, workSpaceToWorld);
    }

    // Append deltaRot to prevMotionMatrix, which we saved last time.
    final SbMatrix newMotionMatrix = 
        appendRotation( prevMotionMatrix, deltaRot, new SbVec3f(0,0,0),
                        workSpaceToLocal );

    // Save our incremental results.
        workSpaceToWorld.multVecMatrix(newHitPt, prevWorldHitPt);
        prevMotionMatrix.copyFrom( newMotionMatrix);

    setMotionMatrix( newMotionMatrix );

    // save information for animation of continuous spining
    prevTime.copyFrom( getEvent().getTime());

    // save increment of rotation for animation
    lastIndex = ((lastIndex+1) % ROT_BUFFER_SIZE);
    rotBuffer[lastIndex].copyFrom(deltaRot);
    timeBuffer[lastIndex].copyFrom(prevTime);

    // check if queue is full
        // if so, through away oldest events from queue
    if (((lastIndex+1) % ROT_BUFFER_SIZE) == firstIndex)
                firstIndex = ((firstIndex+1) % ROT_BUFFER_SIZE);

    return true;
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Compute newHitPt and derive the delta rotation based on prevHitPt and newHitPt.
//    Results of refactoring (MMS Bug: 57374)
//
// Use: protected
//
protected void 
getSphereDeltaRotation(final SbRotation deltaRot, final SbVec3f newHitPt, final SbVec3f prevHitPt, final SbMatrix workingSpace)
{
  // This code block was implemented in rotateDrag() originally
     
  newHitPt.copyFrom( sphereProj.project(getNormalizedLocaterPosition()));
  deltaRot.copyFrom( sphereProj.getRotation(prevHitPt,newHitPt));
}
////////////////////////////////////////////////////////////////////////
//
// Description:
//    Compute newHitPt and derive the delta rotation based on prevHitPt and newHitPt.
//    Results of refactoring (MMS Bug: 57374)
//
// Use: protected
//
protected void 
getStripeDeltaRotation(final SbRotation deltaRot, final SbVec3f newHitPt, final SbVec3f prevHitPt, final SbMatrix workingSpace)
{
  // This code block was implemented in rotateDrag() originally

  newHitPt.copyFrom(stripeProj.project(getNormalizedLocaterPosition()));
  deltaRot.copyFrom(stripeProj.getRotation(prevHitPt,newHitPt));
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Apply a uniform scale to the trackball, by finding the closest point
//    on the line and seeing how much further (orcloser) from the
//    center we are than last time.
//
// Use: private
//
private boolean
scaleDrag()
//
////////////////////////////////////////////////////////////////////////
{
    final SbMatrix workSpaceToLocal = new SbMatrix(), localToWorkSpace = new SbMatrix();
    getPartToLocalMatrix( "antiSquish", workSpaceToLocal, localToWorkSpace);
    final SbMatrix workSpaceToWorld = new SbMatrix(getLocalToWorldMatrix());
    workSpaceToWorld.multLeft( workSpaceToLocal );
    final SbMatrix worldSpaceToWork = new SbMatrix(getWorldToLocalMatrix());
    worldSpaceToWork.multRight( localToWorkSpace );

    final SbVec3f         startHitPt = new SbVec3f(), cntr = new SbVec3f( 0,0,0 );
    final SbLineProjector lineProj = new SbLineProjector();
    worldSpaceToWork.multVecMatrix( getWorldStartingPoint(), startHitPt );

    // make a projection line between the center and the initial hit point.
    lineProj.setLine( new SbLine( cntr, startHitPt ));
    lineProj.setViewVolume(getViewVolume());
    lineProj.setWorkingSpace( workSpaceToWorld );

    final SbVec3f         newHitPt = new SbVec3f();
    // lineProj has the line we are locked to in expanding and contracting
    // the trackball.  Find the point from lineProj closest to the mouseLine
    newHitPt.copyFrom( lineProj.project(getNormalizedLocaterPosition()));

    final SbVec3f oldRadVec = startHitPt.operator_minus(cntr);
    final SbVec3f newRadVec = newHitPt.operator_minus(cntr);

    // [1] Find the distance from the old and new projected points to origin
    float oldRad = oldRadVec.length();
    float newRad = newRadVec.length();

    // [2] Check if we've flipped to the other side of the origin.
    if (startHitPt.dot(newHitPt) < 0.0)
        newRad *= -1.0;

    // [3] Change in scale is ratio of newRad to oldRad
final float TINY =.0001f;
    float delta = (Math.abs(oldRad) < TINY || Math.abs(newRad) < TINY)
                    ? 1.0f : newRad / oldRad;
//#undef TINY

    // constrain the scaling to be greater than getMinScale()
    if (delta < getMinScale())
        delta = getMinScale();
    
    // Set the scaling (to be done relative to scale in startMotionMatrix).
    final SbVec3f scl = new SbVec3f( delta, delta, delta );

    // Save our incremental results.
        workSpaceToWorld.multVecMatrix(newHitPt, prevWorldHitPt);

    // Append this to the startMotionMatrix, which we saved at the beginning
    // of the drag, to find the current motion matrix.
    setMotionMatrix( appendScale( getStartMotionMatrix(), scl, new SbVec3f(0,0,0),
                                    workSpaceToLocal));

    return true;
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Select a new user-selected axis for constrained rotation.
//    When the user selects this special axis, an axis and a wheel
//    are displayed.  Once selected and displayed, the user can 
//    pick the wheel and use it to spin the trackball about this 
//    axis.
//
// Use: private
//
private boolean
userStripeDrag()
//
////////////////////////////////////////////////////////////////////////
{
    final SbMatrix workSpaceToLocal = new SbMatrix(), localToWorkSpace = new SbMatrix();
    getPartToLocalMatrix( "antiSquish", workSpaceToLocal, localToWorkSpace);
    final SbMatrix workSpaceToWorld = new SbMatrix(getLocalToWorldMatrix());
    workSpaceToWorld.multLeft( workSpaceToLocal );
    final SbMatrix worldSpaceToWork = new SbMatrix(getWorldToLocalMatrix());
    worldSpaceToWork.multRight( localToWorkSpace );

    final SbVec3f     newHitPt = new SbVec3f();

    // get the newHitPt
    // temporarily make the tolerance = 1.0, since we want all possible sphere
    // intersections. This makes for a nicer interface of axis picking
    ((SbSphereSectionProjector )sphereProj).setTolerance( 1.0f );
    newHitPt.copyFrom( sphereProj.project(getNormalizedLocaterPosition()));
    ((SbSphereSectionProjector )sphereProj).setTolerance( 0.85f );

    // find the new axis
    userAxisVec.copyFrom(newHitPt);
    userAxisVec.normalize();

    final SbRotation plcmntRot = new SbRotation(new SbVec3f(0,1,0), userAxisVec);
    ((SoRotation )userAxisRotation.getValue()).rotation.setValue( plcmntRot );

    // decide whether or not to display the spinning wheel.
    // only show it if does not line up with a major axis.
    if (   ( Math.abs(userAxisVec.getValueRead()[0]) > 0.99 )
        || ( Math.abs(userAxisVec.getValueRead()[1]) > 0.99 )
        || ( Math.abs(userAxisVec.getValueRead()[2]) > 0.99 ) ) {
        setSwitchValue( userAxisSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );
        setSwitchValue( userRotatorSwitch.getValue(), SoSwitch.SO_SWITCH_NONE );
    }
    else {
        setSwitchValue( userAxisSwitch.getValue(), 1 );
        setSwitchValue( userRotatorSwitch.getValue(), 1 );
    }

    // save intersection for later
    workSpaceToWorld.multVecMatrix( newHitPt, prevWorldHitPt );

    return true;
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Called when the mouse-button is released.
//    Prepares the spinSensor to continue spinning...
//
// Use: private
//
private void
dragFinish()
//
////////////////////////////////////////////////////////////////////////
{
    // Invalidate surroundScale if it exists.
    SoSurroundScale ss = (SoSurroundScale)/*SO_CHECK_PART(this,*/getPart( "surroundScale", false/*SoSurroundScale.class*/);
    if (ss != null)
        ss.invalidate();

    switch ( currentState ) {
        case FREE_ROTATE:
        case X_ROTATE:
        case Y_ROTATE:
        case Z_ROTATE:
        case USER_AXIS_ROTATE:
            // check if we need to continue spinning
            if ( isAnimationEnabled()  
                 && (getEvent().getTime().operator_minus(prevTime)).operator_equal_equal(SbTime.zero())) {   
                    // button came up during motion

                    spinTime.setToTimeOfDay();
                    scheduleRate.copyFrom(new SbTime(FAST_ANIM_RATE));
                    currentState = State.SPINNING;
                    computeAverage = true;
                    spinSensor.setInterval(scheduleRate);
                    spinSensor.schedule();
            }
            else
                currentState = State.INACTIVE;
            break;
        default:
            currentState = State.INACTIVE;
            break;
    }

    setHighlights();

    if (wasSpinningAtDragStart)
        getHandleEventAction().setHandled();
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Resets all variables for turning off the spinSensor
//
// Use: private

private void
resetSpinStuff()
//
////////////////////////////////////////////////////////////////////////
{
    if ( currentState == State.SPINNING ) {
        currentState = State.INACTIVE;
        spinSensor.unschedule();
        renderCaching.setValue( SoInteractionKit.CacheEnabled.AUTO);
    }

    // reset animation queue for spinning
    firstIndex = 0;
    lastIndex = -1;
}

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Routine which animates the ball spinning (called by sensor).
//
// Use: private

private void
spinAnimate()
//
////////////////////////////////////////////////////////////////////////
{
    // get the time difference
    final SbTime time = new SbTime(SbTime.getTimeOfDay());
    final SbTime timeDiff = time.operator_minus(spinTime);
    spinTime.copyFrom(time);    // save current time
    double sec = timeDiff.getValue();
    final float[] angle = new float[1];
    
    // check if average rotation needs to be computed
    if (computeAverage) {
        
        // get number of samples
        int num = (((lastIndex - firstIndex) + 1 + 
            ROT_BUFFER_SIZE) % ROT_BUFFER_SIZE);
        
        // check for not enough samples
        if (num < 2) {
            resetSpinStuff();
            return;
        }
        
        // get average axis of rotation
        // ??? right now only take one sample for axis
        rotBuffer[firstIndex].getValue(averageAxis, angle);

        // get angular velocity
        final SbVec3f axis = new SbVec3f();
        angleVelocity = 0;
        for (int i=0; i<num; i++) {
            int n = (firstIndex + i) % ROT_BUFFER_SIZE;
            rotBuffer[n].getValue(axis, angle);
            angleVelocity += angle[0];
        }
        final SbTime deltaTime = timeBuffer[lastIndex].operator_minus( timeBuffer[firstIndex]);
        
//#ifdef DEBUG
        // check for negative number 
        if (deltaTime.getValue() <= 0.0)
            SoDebugError.post("SoTrackballDragger.spinAnimate",
                                "Zero or negative Dt "+ deltaTime.getValue());
//#endif

        angleVelocity /= deltaTime.getValue();
        
        computeAverage = false;
    }
    
    // calculate the change in rotation
    angle[0] = (float)(angleVelocity * sec);
    
    // append the incremental rotation after the current rotation
    final SbRotation rotIncrement = new SbRotation(averageAxis, angle[0]);

    // recalculate trackball placement
    // 1 -- convert local motion into matrix
            final SbMatrix tm = new SbMatrix();
            tm.setRotate( rotIncrement );
    // 2 -- transform matrix across antisquish node.
            transformMatrixToLocalSpace( tm, tm, new SbName("antiSquish"));
    // 3 -- append matrix to motion
            final SbMatrix newMotion = new SbMatrix(getMotionMatrix());
            setMotionMatrix( newMotion.multLeft( tm ) );

    if ( timeDiff.operator_greater(( scheduleRate.operator_mul( 1 + ANIM_ADJUSTMENT) )))
        // If things are taking significantly longer than expected, 
        // increase the amount of time between calls.
        scheduleRate.operator_mul_equal( 1 + ANIM_ADJUSTMENT );
    else if ( timeDiff.operator_less( ( scheduleRate.operator_mul( 1 + (ANIM_ADJUSTMENT/2.0f)) ))) {
        // otherwise, if things are going quickly, reduce the time. 
        // See which is smaller, scaling down the rate (newRate1) 
        // or a binary-search hop down to the FAST_ANIM_RATE
        final SbTime newRate1 = scheduleRate.operator_mul( 1 - ANIM_ADJUSTMENT );
        final SbTime newRate2 = scheduleRate.operator_minus((scheduleRate.operator_minus(new SbTime(FAST_ANIM_RATE))).operator_mul(0.5f));
        scheduleRate.copyFrom( ( newRate1.operator_less(newRate2) ) ? newRate1 : newRate2);
    }

    // Make sure we don't go below the fastest rate
    if ( scheduleRate.operator_less( new SbTime(FAST_ANIM_RATE)) )
        scheduleRate.copyFrom(new SbTime(FAST_ANIM_RATE));

    // reschedule at the new rate, starting at THIS time + one increment
    // We don't need to unschedule first --  it's done automatically!
    spinSensor.setInterval(scheduleRate);
    spinSensor.setBaseTime(spinTime.operator_add(scheduleRate));
    spinSensor.schedule();
}

//
////////////////////////////////////////////////////////////////////////
// static callbacks stubs
////////////////////////////////////////////////////////////////////////
//

public static void
spinSensorCB(Object v, SoSensor sensor)
{
    SoTrackballDragger m = (SoTrackballDragger ) v;

    m.renderCaching.setValue( SoInteractionKit.CacheEnabled.OFF);
    m.spinAnimate();
}

////////////////////////////////////////////////////////////////////////
//
// Use: protected
//
public void
setAllPartsActive( boolean onOrOff )
//
////////////////////////////////////////////////////////////////////////
{
    int sVal = (onOrOff == true) ? 1 : 0;

    setSwitchValue( rotatorSwitch.getValue(), sVal );
    setSwitchValue( XRotatorSwitch.getValue(), sVal );
    setSwitchValue( YRotatorSwitch.getValue(), sVal );
    setSwitchValue( ZRotatorSwitch.getValue(), sVal );

    SoSwitch sw = (SoSwitch ) userAxisSwitch.getValue();
    if ( sw != null && sw.whichChild.getValue() != SoSwitch.SO_SWITCH_NONE )
        setSwitchValue( userAxisSwitch.getValue(), sVal );

    sw = (SoSwitch ) userRotatorSwitch.getValue();
    if ( sw != null && sw.whichChild.getValue() != SoSwitch.SO_SWITCH_NONE )
        setSwitchValue( userRotatorSwitch.getValue(), sVal );
}

//
////////////////////////////////////////////////////////////////////////
// keypress/release callback function
//
// This assures that the proper changes to the highlights, 
// currentState, and projectors are made
//
// It is called every time a meta key is pressed or released
//
////////////////////////////////////////////////////////////////////////
//

public static void
metaKeyChangeCB( Object object, SoDragger inDragger)
{
    SoTrackballDragger tb = (SoTrackballDragger ) inDragger;

    SoHandleEventAction ha = tb.getHandleEventAction();

    //[1] Only do this if we are grabbing
    if ( ha.getGrabber() != tb )
        return;

    //[2] We only want key press or release events.
    final SoEvent event = tb.getEvent();
    if ( !SoKeyboardEvent.isKeyPressEvent(event, SoKeyboardEvent.Key.ANY) && !SoKeyboardEvent.isKeyReleaseEvent(event, SoKeyboardEvent.Key.ANY))
        return;

    //[3] Is the key constrain or modify?
    final SoKeyboardEvent ke = ( SoKeyboardEvent ) event;
    SoKeyboardEvent.Key key = ke.getKey();
    if ( key == SoKeyboardEvent.Key.LEFT_SHIFT ||
         key == SoKeyboardEvent.Key.RIGHT_SHIFT || 
         key == SoKeyboardEvent.Key.LEFT_CONTROL || 
         key == SoKeyboardEvent.Key.RIGHT_CONTROL ) {

        // We want to end the old gesture and start a new one.

        // [A] Release the grabber. This ends the gesture and calls all 
        //     finishCallbacks (on parent dragger, too, if we're registered)
            ha.releaseGrabber();

        // [B] Set the starting point to be our saved prevWorldHitPt
            tb.setStartingPoint( tb.prevWorldHitPt );

        // [C] Become the grabber again. This begins a new gesture and calls all
        //     startCallbacks (parent dragger, too).  Info like viewVolume, 
        //     viewportRegion, handleEventAction, and tempPathToThis 
        //     is still valid.
            ha.setGrabber(tb);

        // [D] set handled
            ha.setHandled();
    }
}

////////////////////////////////////////////////////////////////////
//  Stubs for callbacks
////////////////////////////////////////////////////////////////////
public static void
startCB( Object object, SoDragger inDragger )
{
    SoTrackballDragger tb = (SoTrackballDragger ) inDragger;
    tb.dragStart();
}

public static void
motionCB( Object object, SoDragger inDragger )
{
    SoTrackballDragger tb = (SoTrackballDragger ) inDragger;
    tb.drag();
}

public static void
finishCB( Object object, SoDragger inDragger )
{
    SoTrackballDragger tb = (SoTrackballDragger ) inDragger;
    tb.dragFinish();
}

public static void
valueChangedCB( Object object, SoDragger inDragger )
{
    SoTrackballDragger m = (SoTrackballDragger ) inDragger;
    SbMatrix motMat = new SbMatrix(m.getMotionMatrix());

    final SbVec3f    trans = new SbVec3f(), scale = new SbVec3f();
    final SbRotation rot = new SbRotation(), scaleOrient = new SbRotation();
    getTransformFast( motMat, trans, rot, scale, scaleOrient);

    // Disconnect the field sensors
    m.rotFieldSensor.detach();
    m.scaleFieldSensor.detach();

    if ( m.rotation.getValue().operator_not_equal(rot) )
        m.rotation.setValue(rot);
    if ( m.scaleFactor.getValue().operator_not_equal(scale) )
        m.scaleFactor.setValue(scale);

    // Reconnect the field sensors
    m.rotFieldSensor.attach( (m.rotation) );
    m.scaleFieldSensor.attach( (m.scaleFactor) );
}

public static void
fieldSensorCB( Object inDragger, SoSensor sensor )
{
    SoTrackballDragger dragger = (SoTrackballDragger ) inDragger;

    SbMatrix motMat = new SbMatrix(dragger.getMotionMatrix());
    dragger.workFieldsIntoTransform( motMat );

    dragger.setMotionMatrix( motMat );
}

public void
setDefaultOnNonWritingFields()
{
    // These nodes may change after construction, but we still
    // don't want to write them out.
    surroundScale.setDefault(true);
    antiSquish.setDefault(true);

    // If the userAxis is not being displayed, then do not write
    // out the userAxisRotation node.
    SoSwitch sw = (SoSwitch ) userAxisSwitch.getValue();
    if ( sw == null || sw.whichChild.getValue() == SoSwitch.SO_SWITCH_NONE ) {
        userAxisRotation.setDefault(true);
    }

    // Call the base class...
    super.setDefaultOnNonWritingFields();
}

public SbProjector initSphereProjector( SbVec3f center, float radius, SbVec3f startWorkSpaceHitPt, SbMatrix workingSpace )
{
  return sphereProj;
}

public SbProjector initStripeProjector( SbLine axis, float radius, SbVec3f startWorkSpaceHitPt, SbMatrix workingSpace )
{
  return stripeProj;
}
    
    
////////////////////////////////////////////////////////////////////////
//
// Description:
//    initialize the class
//
// Use: public, internal

public static void
initClass()
//
////////////////////////////////////////////////////////////////////////
{
    SO__KIT_INIT_CLASS(SoTrackballDragger.class, "TrackballDragger", SoDragger.class);
}

}
