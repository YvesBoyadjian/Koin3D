/*
 *
 *  Copyright (C) 2000 Silicon Graphics, Inc.  All Rights Reserved. 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  Further, this software is distributed without any warranty that it is
 *  free of the rightful claim of any third person regarding infringement
 *  or the like.  Any license provided herein, whether implied or
 *  otherwise, applies only to this software file.  Patent licenses, if
 *  any, provided herein do not apply to combinations of this program with
 *  other software, or any other product whatsoever.
 * 
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
 *  Mountain View, CA  94043, or:
 * 
 *  http://www.sgi.com 
 * 
 *  For further information regarding this notice, see: 
 * 
 *  http://oss.sgi.com/projects/GenInfo/NoticeExplan/
 *
 */


/*
 * Copyright (C) 1990,91   Silicon Graphics, Inc.
 *
 _______________________________________________________________________
 ______________  S I L I C O N   G R A P H I C S   I N C .  ____________
 |
 |   $Revision: 1.1.1.1 $
 |
 |   Description:
 |      This file defines the SoTextureCoordinateBundle class.
 |
 |   Author(s)          : Paul S. Strauss
 |
 ______________  S I L I C O N   G R A P H I C S   I N C .  ____________
 _______________________________________________________________________
 */

package jscenegraph.database.inventor.bundles;

import com.jogamp.opengl.GL2;

import jscenegraph.coin3d.inventor.elements.SoGLMultiTextureCoordinateElement;
import jscenegraph.coin3d.inventor.elements.SoGLMultiTextureCoordinateElement.SoTexCoordTexgenCB;
import jscenegraph.coin3d.inventor.elements.SoGLMultiTextureEnabledElement;
import jscenegraph.coin3d.inventor.elements.SoMultiTextureCoordinateElement;
import jscenegraph.coin3d.inventor.elements.SoMultiTextureCoordinateElement.SoTextureCoordinateFunctionCB;
import jscenegraph.coin3d.inventor.elements.SoTextureUnitElement;
import jscenegraph.database.inventor.SbBox3f;
import jscenegraph.database.inventor.SbVec2f;
import jscenegraph.database.inventor.SbVec3f;
import jscenegraph.database.inventor.SbVec4f;
import jscenegraph.database.inventor.SbVec4fSingle;
import jscenegraph.database.inventor.actions.SoAction;
import jscenegraph.database.inventor.elements.SoGLCacheContextElement;
import jscenegraph.database.inventor.nodes.SoNode;
import jscenegraph.database.inventor.nodes.SoShape;
import jscenegraph.port.Ctx;


///////////////////////////////////////////////////////////////////////////////
///
////\class SoTextureCoordinateBundle
///
///  Bundle that allows shapes to deal with texture coordinates more
///  easily. This class provides a fairly simple interface to texture
///  coordinate handling, including default texture coordinate
///  generation. This can be used during either rendering or primitive
///  generation.
///
///  This class can be used during either rendering or primitive
///  generation. For primitive generation, there are two cases,
///  distinguished by the flag returned by isFunction(). If this
///  flag is TRUE, the texture coordinates are to be generated using
///  the get(point, normal) method, which uses a software texture
///  coordinate function. (This process is also used for texture
///  coordinates that are generated by default when necessary - in this
///  case, the function does a linear map across two sides of the
///  bounding box of the shape.) If the isFunction() flag is FALSE, the
///  coordinates are accessed directly from the element using the
///  get(index) method.
///
///  For GL rendering, there is an additional case. If
///  needCoordinates() returns FALSE, no texture coordinates need to be
///  sent at all, and the bundle does not have to be used for anything
///  else. Otherwise, send(index) should be used.
///
//////////////////////////////////////////////////////////////////////////////

/**
 * @author Yves boyadjian
 *
 */
public class SoTextureCoordinateBundle extends SoBundle {

  private
    //! TextureCoordinate elements:
    SoMultiTextureCoordinateElement    texCoordElt;
    private SoGLMultiTextureCoordinateElement  GLTexCoordElt;

    private boolean              needCoords;     //!< Texture coordinates are needed
    private boolean              isFunc;         //!< Coordinates generated by function
    private boolean              isRendering;    //!< Bundle being used for rendering
    private boolean              setFunction;    //!< We set default coord func in state

    //! These indicate the dimensions used for S and T for default
    //! texture coordinate generation
    private int                 coordS, coordT;
    //! These hold the vectors used for default texture coordinate generation
    private final SbVec4fSingle             sVector = new SbVec4fSingle(), tVector = new SbVec4fSingle();
    //! This holds the texture coords from a vertexProperty node:
    private SbVec2f[]      tCoords;



    //! Constructor - takes the action the bundle is used for and a
    //! flag to indicate whether the bundle is being used for
    //! rendering. If this is true, the bundle can be used to send
    //! texture coordinates to GL. If it is FALSE, the setUpDefault
    //! flag (default true) indicates whether to set up a texture
    //! coordinate function if the binding is DEFAULT. Shapes can pass
    //! FALSE here if they are picking and want to delay computation of
    //! the texture coordinates until an intersection is found.
	
	// java port
    public SoTextureCoordinateBundle(SoAction action, boolean forRendering) {
    	this(action, forRendering, true);
    }
    public SoTextureCoordinateBundle(SoAction action, boolean forRendering,
                              boolean setUpDefault) {
    	super(action);
    isRendering = forRendering;
    //??? When Gavin gets back, he can explain if tCoords is really needed:
    tCoords = null;

    setFunction = false;

    if (isRendering)
        setUpForGLRender(action);
    else
        setUpForPrimGen(action, setUpDefault);
    }
    
////////////////////////////////////////////////////////////////////////
//
// Description:
//    Destructor
//
// Use: public

public void destructor()
//
////////////////////////////////////////////////////////////////////////
{
    if (setFunction) state.pop();
    //super.destructor();
}

    
    
        //! Returns true if texture coordinates are needed at all
    public boolean              needCoordinates() { return needCoords; }

    //! return value to determine which get() to use.
    public boolean              isFunction() { return isFunc; }

    //! Returns texture coordinate computed by function during
    //! primitive generation or rendering
    public SbVec4f             get(final SbVec3f point, final SbVec3f normal) 
        { return texCoordElt.get(point, normal); }

    //! Returns indexed texture coordinate during primitive generation
    //! or rendering
    public SbVec4f             get(int index) 
        { if (tCoords != null) return(new SbVec4f(tCoords[index].getValueRead()[0],tCoords[index].getValueRead()[1],
                        0.0f, 1.0f)); 
                else return texCoordElt.get4(index); }

    //! Sends indexed texture coordinate to GL during rendering
    public void                send(int index) { GLTexCoordElt.send(index); }

    public void send( int index, final SbVec3f point,
            final SbVec3f normal) {
    /*glElt*/GLTexCoordElt.send(index, point, normal);
  }


    
////////////////////////////////////////////////////////////////////////
//
// Description:
//    Sets up bundle for primitive generation.
//
// Use: private

private void
setUpForPrimGen(SoAction action,
                                           boolean setUpDefault)
//
////////////////////////////////////////////////////////////////////////
{
    // Primitive generation always requires texture coordinates
    needCoords = true;

    texCoordElt   = SoMultiTextureCoordinateElement.getInstance(state);
    GLTexCoordElt = null;
    
    int unit = SoTextureUnitElement.get(state); // COIN 3D YB

    switch (texCoordElt.getType(unit)) { // COIN 3D YB

      case EXPLICIT:
        if (texCoordElt.getNum(unit) < 1) {
            // Don't bother computing the function if not requested
            if (setUpDefault) {
                // Set up a texture coordinate function that compute the
                // texture coordinates. We need to do this through the
                // element so the state can be restored correctly.
                state.push();
                SoNode currentNode = action.getCurPathTail(); 
                SoMultiTextureCoordinateElement.setFunction(state, currentNode,
                                                        generateCoordCB, this);
                // Get the new instance in here
                texCoordElt = SoMultiTextureCoordinateElement.getInstance(state);

                setUpDefaultCoordSpace(action);

                setFunction = true;
            }
            isFunc = true;
        } else {
            isFunc = false;
        }
        break;

      case FUNCTION:
        isFunc = true;
        break;
    }
}

    
////////////////////////////////////////////////////////////////////////
//
// Description:
//    Sets up bundle for GL rendering.
//
// Use: private

private void
setUpForGLRender(SoAction action)
//
////////////////////////////////////////////////////////////////////////
{
    int unit = SoTextureUnitElement.get(action.getState()); // COIN 3D YB	
	
    if (! SoGLMultiTextureEnabledElement.get(action.getState(),unit))
        needCoords = isFunc = false;

    else {
        // Access a GL version of the element for sending texture
        // coordinates to GL
        texCoordElt   = SoMultiTextureCoordinateElement.getInstance(state);
        GLTexCoordElt = ( SoGLMultiTextureCoordinateElement ) texCoordElt;

        switch (GLTexCoordElt.getType(unit)) {

        	case DEFAULT:
            this.initDefault(action);
            break;
          case EXPLICIT:
            if (GLTexCoordElt.getNum(unit) > 0) {
                needCoords = true;
                isFunc     = false;
            } else {
                // Set up the default coordinate function before it is
                // used by the SoGLTextureCoordinateElement
                setUpDefaultCoordSpace(action);

                // Set up a texture coordinate function that will do the
                // correct tex gen stuff. We need to do this through the
                // element so the state can be restored correctly.
                state.push();
                setFunction = true;
                SoNode currentNode = action.getCurPathTail();
                SoGLMultiTextureCoordinateElement.
                    setTexGen(state, currentNode, setUpTexGenCB, this,
                              generateCoordCB, this);

                // Get the new instance in here
                texCoordElt   = SoMultiTextureCoordinateElement.getInstance(state);
                GLTexCoordElt = ( SoGLMultiTextureCoordinateElement )
                    texCoordElt;


                // No longer need coordinates, since texgen does the job
                needCoords = false;

                // Set this flag to true so that if we are using primitive
                // generation to do the rendering, we can tell that we
                // have a function to use
                isFunc = true;
            }
            break;

          case FUNCTION:
//#ifdef DEBUG
//            SoDebugError.post(
//                "SoTextureCoordinateBundle.setUpForGLRender",
//                "GLTextureCoordinateElement is FUNCTION!");
//#endif
            needCoords = isFunc = false;
            break;
        }
    }
}

/**
 * YB TODO
 * @param action
 */
private void initDefault(SoAction action) {
    // Set up the default coordinate function before it is
    // used by the SoGLTextureCoordinateElement
    setUpDefaultCoordSpace(action);

    // Set up a texture coordinate function that will do the
    // correct tex gen stuff. We need to do this through the
    // element so the state can be restored correctly.
    state.push();
    setFunction = true;
    SoNode currentNode = action.getCurPathTail();
    SoGLMultiTextureCoordinateElement.
        setTexGen(state, currentNode, setUpTexGenCB, this,
                  generateCoordCB, this);

    // Get the new instance in here
    texCoordElt   = SoMultiTextureCoordinateElement.getInstance(state);
    GLTexCoordElt = ( SoGLMultiTextureCoordinateElement )
        texCoordElt;


    // No longer need coordinates, since texgen does the job
    needCoords = false;

    // Set this flag to true so that if we are using primitive
    // generation to do the rendering, we can tell that we
    // have a function to use
    isFunc = true;
	
}
////////////////////////////////////////////////////////////////////////
//
// Description:
//    Sets up parameters for computing default texture coordinates.
//    The default coordinates are defined based on the object-space
//    bounding box of the shape. The S coordinate ranges from 0 to 1
//    over the side of the box with the largest dimension, and the T
//    coordinate ranges over the side of the box with the next largest
//    dimension. The repeat size is the same in both dimensions so
//    that a square texture remains square.
//
// Use: private

private void
setUpDefaultCoordSpace(SoAction action)
//
////////////////////////////////////////////////////////////////////////
{
    SoNode tail = action.getCurPathTail();
//#ifdef DEBUG
//    if (!tail->isOfType(SoShape::getClassTypeId())) {
//        SoDebugError::post(
//            "SoTextureCoordinateBundle::setUpDefaultCoordSpace",
//            "Tail of path is not a shape node!");
//    }
//#endif
    SoShape shape = (SoShape )tail;

    final SbBox3f box = new SbBox3f();
    final SbVec3f center = new SbVec3f();
    shape.computeBBox(action, box, center);

    final SbVec3f       min    = box.getMin();
    final SbVec3f             boxSize = box.getMax().operator_minus(min);

    // Look for the largest two dimensions of the box
    if (boxSize.getValueRead()[0] > boxSize.getValueRead()[1] && boxSize.getValueRead()[0] > boxSize.getValueRead()[2]) {
        coordS = 0;
        coordT = boxSize.getValueRead()[1] > boxSize.getValueRead()[2] ? 1 : 2;
    }
    else if (boxSize.getValueRead()[1] > boxSize.getValueRead()[2]) {
        coordS = 1;
        coordT = boxSize.getValueRead()[0] > boxSize.getValueRead()[2] ? 0 : 2;
    }
    else {
        coordS = 2;
        coordT = boxSize.getValueRead()[0] > boxSize.getValueRead()[1] ? 0 : 1;
    }

    // Set up vectors for S and T coordinates. The length of the
    // vectors should be the size of the box in that dimension. Since
    // we want the texture to remain square, we use the same length
    // for both dimensions.
    float tmp = 1.0f / boxSize.getValueRead()[coordS];
    sVector.setValue(0.0f, 0.0f, 0.0f, -min.getValueRead()[coordS] * tmp);
    tVector.setValue(0.0f, 0.0f, 0.0f, -min.getValueRead()[coordT] * tmp);
    sVector.getValue()[coordS] = tVector.getValue()[coordT] = tmp;
}



// java port
private final static SoTextureCoordinateFunctionCB generateCoordCB  = new SoTextureCoordinateFunctionCB() {

	@Override
	public SbVec4f apply(Object userData, SbVec3f point, SbVec3f normal) {
		return generateCoord(userData,point,normal);
	}
	
};

////////////////////////////////////////////////////////////////////////
//
// Description:
//    Callback registered with SoMultiTextureCoordinateElement for
//    computing texture coordinate from point and normal - used for
//    default coordinate generation. The userData arg will be "this".
//
// Use: private

private static SbVec4f 
generateCoord(Object userData,
                                         final SbVec3f point,
                                         final SbVec3f   normal )
//
////////////////////////////////////////////////////////////////////////
{
    SoTextureCoordinateBundle tcb = (SoTextureCoordinateBundle ) userData;

    final SbVec4f      result = new SbVec4f();

    // The S and T coordinates of the result are the dot products of
    // the point with sVector and tVector. Since this computation is
    // done very frequently (during primitive generation for picking
    // on vertex-based shapes), we can avoid some operations that
    // result in 0 by doing the dot products explicitly.
    int sDim = tcb.coordS, tDim = tcb.coordT;


    result.setValue(point.getValueRead()[sDim] * tcb.sVector.getValueRead()[sDim] + tcb.sVector.getValueRead()[3],
                    point.getValueRead()[tDim] * tcb.tVector.getValueRead()[tDim] + tcb.tVector.getValueRead()[3],
                    0.0f,
                    1.0f);

    return result;
}


////////////////////////////////////////////////////////////////////////
//
// Description:
//    Callback registered with SoGLTextureCoordinateElement for
//    setting up GL texture generation for default coordinates. The
//    userData arg will be "this".
//
// Use: private

private static final SoTexCoordTexgenCB setUpTexGenCB = new SoTexCoordTexgenCB() {

	@Override
	public void run(Object userData) {
		setUpTexGen( userData);		
	}
	
};

private static void
setUpTexGen(Object userData)
//
////////////////////////////////////////////////////////////////////////
{
    SoTextureCoordinateBundle tcb = (SoTextureCoordinateBundle ) userData;
    
    GL2 gl2 = Ctx.get(SoGLCacheContextElement.get(tcb.state));

    gl2.glTexGenf(GL2.GL_S, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_OBJECT_LINEAR);
    gl2.glTexGenfv(GL2.GL_S, GL2.GL_OBJECT_PLANE, tcb.sVector.getValueRead(),0);

    gl2.glTexGenf(GL2.GL_T, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_OBJECT_LINEAR);
    gl2.glTexGenfv(GL2.GL_T, GL2.GL_OBJECT_PLANE, tcb.tVector.getValueRead(),0);

    SbVec4f t = new SbVec4f();
    t.setValue(0,0,1,0);
    gl2.glTexGeni(GL2.GL_R, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_OBJECT_LINEAR);
    gl2.glTexGenfv(GL2.GL_R, GL2.GL_OBJECT_PLANE, t.getValueRead(),0);    
    t.setValue(0,0,0,1);
    gl2.glTexGeni(GL2.GL_Q, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_OBJECT_LINEAR);
    gl2.glTexGenfv(GL2.GL_Q, GL2.GL_OBJECT_PLANE, t.getValueRead(),0);    
}

    
}
